# -*- coding: utf-8 -*-
"""21201068_Anika Bushra_CSE422_12_Assignment02_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VJE4j5RfqQF1MdUKQ6JfA7azSohz2Uf7
"""

import random

f1 = open('D:/input.txt', 'r')
f2 = open('D:/output.txt', 'w')
lines = f1.readline().strip()
c, t = map(int, lines.split())

def create_genes(c, t):
    schedule = [0] * (c * t)
    slot = list(range(c * t))
    random.shuffle(slot)

    for i in range(c):
        schedule[slot[i]] = 1
    return schedule

def calculate_fitness(schedule, c, t):
    o_penalty = 0
    c_penalty = 0

    for i in range(t):
        current = []
        for j in range(c):
            current.append(schedule[i * c + j])
        o_penalty += max(0, sum(current) - 1)
    counter = [0] * c

    for k in range(t):
        for m in range(c):
            counter[m] += schedule[k * c + m]
    for n in counter:
        c_penalty += abs(n - 1)
    f = -(o_penalty + c_penalty)
    return f

def selection(p, f_score):
    min_score = min(f_score)
    fixed = []

    for i in f_score:
        fixed.append(i - min_score + 1)
    parent = random.choices(p, weights = fixed, k = 2)
    return parent

def single_point_crossover(p1, p2):
    length = len(p1)
    idx1 = random.randint(1, length - 2)
    idx2 = random.randint(idx1 + 1, length - 1)
    off1 = p1[:idx1] + p2[idx1:idx2] + p1[idx2:]
    off2 = p2[:idx1] + p1[idx1:idx2] + p2[idx2:]
    return off1, off2

def mutation(schedule, rate = 0.1):
    for i in range(len(schedule)):
        if random.random() < rate:
            schedule[i] = 1 - schedule[i]

def genetic_algorithm(c, t, p_size = 10, gen = 100):
    p = [create_genes(c, t) for i in range(p_size)]
    fitness = [calculate_fitness(schedule, c, t) for schedule in p]

    count = 0
    while count < gen:
        if max(fitness) >= 0:
            break

        new = []
        for idx in range(p_size // 2):
            p1, p2 = selection(p, fitness)
            c1, c2 = single_point_crossover(p1, p2)
            mutation(c1)
            mutation(c2)
            new.extend([c1, c2])
        p = new
        fitness = [calculate_fitness(schedule, c, t) for schedule in p]
        count += 1
    best_idx = fitness.index(max(fitness))
    worst_idx = fitness.index(min(fitness))
    print(p[worst_idx], fitness[worst_idx])
    return p[best_idx], fitness[best_idx]

def two_point_crossover():
    p = [create_genes(c, t) for i in range(10)]
    p1, p2 = random.sample(p, 2)
    off1, off2 = single_point_crossover(p1, p2)

    temp = 'Parent 1:  ' + ''.join(map(str, p1)) + '\n'\
            + 'Parent 2:  ' + ''.join(map(str, p2)) + '\n'\
            + 'Offspring 1: ' + ''.join(map(str, off1)) + '\n'\
            + 'Offspring 2: ' + ''.join(map(str, off2)) + '\n'
    return temp


genes, b_fitness = genetic_algorithm(c, t)
output1 = 'Best Chromosome: ' + ''.join(str(g) for g in genes) + '\n' + 'Best Fitness: ' + str(b_fitness) + '\n'
output2 = two_point_crossover()
output1 += output2

f2.write(output1)

f1.close()
f2.close()